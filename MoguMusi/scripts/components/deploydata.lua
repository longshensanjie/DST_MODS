---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/7/23 17:13
---
local cookpot=require("cookpot")
local function Rotate(x, y, radin)
    return x * math.cos(radin) - y * math.sin(radin),
           x * math.sin(radin) + y * math.cos(radin)
end
local function PointToPointDistance(x1, x2, y1, y2)
    return math.sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2)
end
local DeployParm = Class(function(self, inst)
    self.inst = inst
    self.center_x = 0
    self.center_z = 0
    self.step = 7.8 -- 圆心角
    self.radius = 14.8 -- 半径
    self.deploynum = 46 -- 部署数量
    self.space = 0.5 -- 层间额外间隔
    self.spin = 0 -- 旋转角度
    self.range = 360 -- 部署的范围
    self.interval = 2 -- 间隔
    self.center_x = 0 -- x坐标
    self.center_z = 0 -- z坐标
    self.shape = "circle" -- 形状
    self.mode = 0 -- 计算方式
    self.direction = true
    self.order=false
    self.scheme=""
    self.isFullLayers = false
end)
function DeployParm:setParm(key, value) self[key] = value end
function DeployParm:getParm(parm) return self[parm] end
function DeployParm:setRadius(value)
    self.radius = value
    local a = self.interval
    local oldstep = math.deg(
                        math.acos((2 * value ^ 2 - a ^ 2) / (2 * value ^ 2)))
    local arclength = math.abs(self.range)
    for i = 1, arclength / 2, 1 do
        if oldstep >= arclength / (i + 1) then
            self.step = arclength / i
            self.deploynum = i
            break
        end
    end
    if arclength / 2 < 1 then self.deploynum = 1 end
end
function DeployParm:setStep(value)
    value=math.abs(value)
    self.step = math.abs(self.range) / value
    local a = self.interval
    local A = self.step
    local radius = a / (2 * math.cos(math.rad(90 - A / 2)))
    self.radius = math.abs(value) ~= 1 and math.ceil(radius * 100+1) / 100 or 0
    --[[这里可能会出现cos90°然后除零的情况，不过编译器中精度问题cos90°
     并不等于于零,在计算半径时也会出现偏差,当数量只有一个的时候种在圆心就好了]] --
    self.deploynum = value
end

function DeployParm:calStep(side, inv)
    local b = side or self.radius
    if b == 0 then return self.range end
    local a = inv or self.interval
    local oldstep = math.deg(math.acos((2 * b ^ 2 - a ^ 2) / (2 * b ^ 2)))
    local arclength = self.range + 0.01
    local newstep = self.step
    for i = 1, arclength / 2, 1 do
        if oldstep >= arclength / (i + 1) then
            newstep = arclength / i
            break
        end
    end
    return newstep
end
function DeployParm:setInterval(value)
    if value == nil or value == 0 then return end
    self.interval = math.abs(value)
    if self.mode == 0 then self:setRadius(self.radius) end
    if self.mode == 1 then self:setStep(self.deploynum) end
end

function DeployParm:setspin(value)
    self.spin = value
    if self.mode == 0 then
        self:setRadius(self.radius)
    elseif self.mode == 1 then
        self:setStep(self.deploynum)
    end

end
function DeployParm:setRange(value)
    self.range = value
    if self.mode == 0 then self:setRadius(self.radius) end
    if self.mode == 1 then self:setStep(self.deploynum) end
end
function DeployParm:setMode(value)
    if value == "radiusangle" then
        self.mode = 0
        self:setRadius(self.radius)
    elseif value == "angleradius" then
        self.mode = 1
        self:setStep(self.deploynum)
    elseif value == "custom" then
        self.mode = 2
    end
end

function DeployParm:getMode()
    if self.mode == 0 then
        return "radiusangle"
    elseif self.mode == 1 then
        return "angleradius"
    elseif self.mode == 2 then
        return "custom"
    end
end
-- print(ThePlayer.components.deploydata.deploynum)
function DeployParm:GetCirclePosition()
    local DeployPosition = {}
    local pos={}
    local r =math.abs(self.radius)
    local step = self.step
    local LayerSpace = self.isFullLayers and (self.interval + self.space) or
                           r + self.interval
    local startAngle = self.direction and self.spin or self.spin + self.range
    local endAngle = self.direction and self.spin + self.range or self.spin
    repeat
        if self.mode ~= 2 and self.isFullLayers then
            step = self:calStep(r, self.interval)
        end
        step = self.direction and step or -step
        for Angle = startAngle, endAngle, step do
            local theta = math.rad(Angle)
            local x = math.cos(theta) * r
            local z = math.sin(theta) * r
            table.insert(DeployPosition,
                         Vector3(x + self.center_x, 0, z + self.center_z))
                         --print(x,z)
        end
        r = r - LayerSpace
    until (r < LayerSpace/2)
    local count = 0
    for _ = 0, self.range, step do count = count + 1 end
    if count > self.deploynum then table.remove(DeployPosition, count) end
if  self.order then
    for i=1,#DeployPosition do
        table.insert(pos,table.remove(DeployPosition))
    end
    return pos
end
    return DeployPosition
end

function DeployParm:GetStraightPosition()
    local DeployPosition = {}
    local num = math.floor(math.abs(self.radius) / self.interval)
    local length = (num - 1) * (self.interval) / 2 + 0.001
    for i = -length, length, (self.interval + 0.0001) do
        local x, y = Rotate(0, i, math.rad(self.spin))
        table.insert(DeployPosition,
                     Vector3(self.center_x + x, 0, self.center_z + y))
    end
    return DeployPosition
end

function DeployParm:GetCardioidPosition()
    local pos = {}
    local pos2 = {}
    local center_x = self.center_x
    local center_z = self.center_z
    local rot = math.rad(self.spin)
    local length = math.abs(self.radius)
    -- 心形线有点特殊，
    -- local LayerSpace= self.isFullLayers and (self.interval+self.space)   or  self.radius
    -- local offset_x=LayerSpace*math.cos(rot-math.pi/2)
    -- local offset_z=LayerSpace*math.sin(rot-math.pi/2)
    -- repeat
    local x1, y1, st = 0, 0, 0
    for i = math.pi / 2, math.pi * 3 / 2, 0.1 do
        local s = math.sin(i)
        local c = math.cos(i)
        local r = length *
                      ((s * math.sqrt(math.abs(c))) / (s + 7 / 5) - 2 * s + 2)
        x1 = r * c
        if math.abs(x1) > self.interval / 2 then
            y1 = r * s
            local nx1, ny1 = Rotate(x1, y1, rot)
            local top_x, top_y = Rotate(0, y1 - math.abs(x1) * 2 *
                                            math.cos(math.pi / 6), rot)
            table.insert(pos, Vector3(center_x - top_x, 0, center_z + top_y))
            table.insert(pos, Vector3(nx1 + center_x, 0, ny1 + center_z))
            local nnx1, nny1 = Rotate(0 - x1, y1, rot)
            table.insert(pos2, Vector3(center_x + nnx1, 0, nny1 + center_z))
            st = i
            break
        end
    end
    for i = st, math.pi * 3 / 2, math.pi / 360 do
        local s = math.sin(i)
        local c = math.cos(i)
        local r = length *
                      ((s * math.sqrt(math.abs(c))) / (s + 7 / 5) - 2 * s + 2)
        local x2 = r * c
        local y2 = r * s
        if PointToPointDistance(x1, x2, y1, y2) >= self.interval then
            x1 = x2
            y1 = y2
            local nx1, ny1 = Rotate(x1, y1, rot)
            table.insert(pos, Vector3(nx1 + center_x, 0, ny1 + center_z))
            local nnx1, nny1 = Rotate(0 - x1, y1, rot)
            table.insert(pos2, Vector3(center_x + nnx1, 0, nny1 + center_z))
        end
    end
    local bottom_x, bottom_y = Rotate(0, y1 - math.abs(x1) * 2 *
                                          math.cos(math.pi / 6), rot)

    table.insert(pos, Vector3(center_x + bottom_x, 0, center_z + bottom_y))
    for _ = 1, #pos2 do table.insert(pos, table.remove(pos2)) end
    --     center_x=center_x-offset_x
    --     center_z=center_z-offset_z
    --     length=length-LayerSpace
    -- until(length<LayerSpace)
    return pos
end

function DeployParm:GetSquarePosition()
    local pos = {}
    local num = math.floor(math.abs(self.radius)/ self.interval)
    local flags = true
    local length = (num - 1) * (self.interval + 0.02) / 2
    for i = length, -length, -(self.interval + 0.001) do
        if flags then
            for j = -length, length, self.interval + 0.001 do
                local x, y = Rotate(j, i, math.rad(self.spin + 90))
                table.insert(pos,
                             Vector3(self.center_x + x, 0, self.center_z + y))
            end
        else
            for j = length, -length, -(self.interval + 0.001) do
                local x, y = Rotate(j, i, math.rad(self.spin + 90))
                table.insert(pos,
                             Vector3(self.center_x + x, 0, self.center_z + y))
            end
        end
        flags = not flags
    end
    return pos
end
function DeployParm:GetSpecialPosition()
    local pos={}
    if cookpot[self.scheme] then
    for k, v in pairs(cookpot[self.scheme]) do
        local x,z=Rotate(v.x,v.z,math.rad( v.spin+self.spin))
        table.insert(pos,{item=v.item,skin=v.skin,x=x+self.center_x,z=z+self.center_z})
    end
end
    return pos
end
return DeployParm
